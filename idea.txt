有校验、重发机制的串口通信

数据帧定义
55 AA XX YY ZZ LL ... CC AA
1、55h AAh 帧同步字， AA 作为帧终结字
2、XX 源地址码，  排除 55h/AAh
3、YY 目标地址码，排除 55h/AAh
4、ZZ 帧序号，从 0 开始，直到 FF，循环回来，要 排除 55h/AAh
5、LL 帧长度，A9h，这样就不会遇到 AAh 的情况了
   因此，最大payload 就是 A9h -5 = A4h（164）
   有一种特殊情况，LL 帧长度出现误码怎么办？
   解决方案，发 两次 帧长， 万一 两次帧长不一致，先通过校验码确定两个帧长是正确的
   如果都对不上，就 放弃掉这个企图，再通过 AA 55 AA 的同步字，找下一帧。
6、CC CRC校验符
7、Payload中若出现 55h AAh，由于 LL 的控制作用，就不会被识别为帧头

返回帧定义
返回帧有优先发送的权利，只有所有的返回帧都发完了，才能发数据帧
因为 AA 不可能出现在帧长中，用 AA 作为返回帧的 特征字
1、如果通过校验
   55 AA XX YY ZZ AA 55 CC
2、如果没有通过校验
   55 AA XX YY ZZ AA AA CC
   没有通过校验的数据帧，要优先重传

因为 pyserial 的 write 方法是阻塞的，所以 写的时候，不能 同时读。
两个解决方法：
1、 把 读写 变得 零碎一些，不要 写一个 大块的数据，这样就有 读的机会了
    实际 上由于 串口 缓冲的作用，一端 在写的时候，另一端 也可以在写，
    而当需要读的时候，直接读的是 串口缓冲，这样 也基本上 是同步的了。
2、 写一个 ctype 的扩展库，把 读写 分开到不同的 多核线程里，就可以 真实的 并行读写

负载如何被传递到类中？
写一个接口函数，把python的pipe转换成字符传入接口函数

接口函数使用free pascal写，避免安装复杂的windows sdk
接口函数写成 dll/so，这样可以 实现真实的线程化

异步的问题，无需考虑太多，这个要用 串口的 write 阻塞机制来解决，write 阻塞了，就拒绝接收负载数据
要有一个标志，说明 write 缓冲完成了多少，用接口来 标识 处于阻塞，避免 无谓的数据准备

使用 eventlet的异步兼容？

