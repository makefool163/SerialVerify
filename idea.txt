有校验、重发机制的串口通信

1   不搞主从机制。网络是双工模式，双向RS-232也是双工模式，主从模式会降低通信效率

2   数据包
    最大长度 960  --保证在 至少在9600bit/s下，能在 1秒 内发完

2.1 包头
    AA  起始字符，二进制形式是 10101010
        负载内容中若有 AA，就展开成两个 AA
    XY  传输序号
        X 数据内容序号，第0位是地址码，由两台设备最初连接握手时约定
                       第1-7位，表示待发缓冲的位置，这样协议支持 64个待发缓冲队列
        Y 数据包序号，待发缓冲会被分拆成 多个 数据包负载，以适应校验、重发机制
    JJ  检验码
        数据负载的 计算 校验码
    LL  数据包长度，这个包长度 不是 实际长度，而是 实际长度 除 0xFF 的模，用来降低 开销量
2.2 数据负载
    
3 应答包
    AA  起始字符
    XY  传输序号
    JJ  成功、失败标志
    LL  设置为 00，表示本 信元 没有负载数据
  应答包高于所有数据包
  应答失败的数据包会优先重传
  两端都会对 记录 重传的次数，重传次数 若大于某个阈值，
            说明系统已不可用，发出告警 信号，供上端进行处理
            系统 进入不可用状态时， 两端 不再 发送数据，进入 握手 模式

4 握手过程
    握手 字符 0x85 （0101010101H），发送口每隔 0.5秒（此时间无需精确），
    连续发 8个握手字符
    若收到 了 8个 握手字符，就 把串口读取缓冲区清空，进入 令牌 争夺过程
    令牌争夺 过程： 
    1  以 2 秒位 最长时限，设置 一个随机 开始时间，向对方发 令牌符 "makefool"
       发完令牌符后，依据 波特率 计算 发送令牌符的 时间，等待计算时间后，立即读 串口
       若 没有 读到数据，说明 自己 已取得 令牌
       若读到了 串口 数据，说明出现了 令牌竞争， 则继续 循环过程 1
    2  在过程 1 期间，收到令牌符 "makefool" 信号，表示 对方 已取得 令牌，自己已失去 令牌
    3  获取了 令牌 的一方 地址码 为 0， 另一方 地址码 为 1

数据帧定义
85 AA XX YY ZZ LL ... CC
1、55h AAh 使帧同步字
2、XX 源地址码，  排除 55h/AAh
3、YY 目标地址码，排除 55h/AAh
4、帧序号，从 0 开始，直到 FF，循环回来，要 跳过 85
5、LL 帧长度，A9h，这样就不会遇到 AAh 的情况了
   因此，最大payload 就是 A9h -5 = A4h（164）
6、CC CRC校验符
7、Payload中若出现 55h AAh，由于 LL 的控制作用，就不会被识别为帧头

返回帧定义
因为 AA 不可能出现在帧长中，用 AA 作为返回帧的 特征字
1、如果通过校验
   85 AA XX YY ZZ AA 85 CC
2、如果没有通过校验
   85 AA XX YY ZZ AA AA CC

负载如何被传递到类中？
写一个接口函数，把python的pipe转换成字符传入接口函数

接口函数使用free pascal写，避免安装复杂的windows sdk
接口函数写成 dll/so，这样可以 实现真实的线程化

异步的问题，无需考虑太多，这个要用 串口的 write 阻塞机制来解决，write 阻塞了，就拒绝接收负载数据
要有一个标志，说明 write 缓冲完成了多少，用接口来 标识 处于阻塞，避免 无谓的数据准备

使用 eventlet的异步兼容？

